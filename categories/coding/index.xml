<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>coding on Chang's blog</title><link>//blog.yech.xyz/categories/coding/</link><description>Recent content in coding on Chang's blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>2020 by Ye Chang</copyright><lastBuildDate>Mon, 23 Mar 2020 22:38:14 +0800</lastBuildDate><atom:link href="//blog.yech.xyz/categories/coding/index.xml" rel="self" type="application/rss+xml"/><item><title>Fix a Bug in Quickrun, a Vim Plugin</title><link>//blog.yech.xyz/posts/fix_a_bug_in_quickrun_vim_plugin/</link><pubDate>Mon, 23 Mar 2020 22:38:14 +0800</pubDate><guid>//blog.yech.xyz/posts/fix_a_bug_in_quickrun_vim_plugin/</guid><description>Quickrun1是一个整合了常用编程语言运行命令的 Vim Plugin，可以通过 :Quickrun 命令，或是自定义的映射，一键运行当前文件。
今天在 Vim 中运行一个 R 文件时，发现结果一直输出“file name is missing”。查看错误日志，却发现一切正常; 用各种关键词搜索这个输出信息，均未能找到有用的信息; 查看插件的源码，也没看到这个报错的出处。
这时只能从文件入手，把文件（test.R）删到只剩下一句命令：
#!/usr/bin/env Rscript # -*- coding: utf-8 -*- print(&amp;#39;hello&amp;#39;) 运行了一下，依然是相同的报错。 再次陷入了 “越是容易上手的东西，越不容易使用” 的魔咒。
无奈之下只好把文件头的注释也删了。 这时，惊奇地发现居然成功地看到了正常的输出。 也就是说是文件头（shebang）2间接地触发了报错。 但是 Quickrun 是根据根据文件类型来触发运行命令的，理论上不应该受到文件注释的影响。 唯一的解释是 Quickrun 中加入了对 shebang 的识别机制。
再次翻看源码和文档，终于发现其中 R 语言的运行命令为：%c %o --no-save --slave %a &amp;lt; %s。 默认情况下 %c 会被替换为 comand 参数中的设定值，即 R。 但是在识别到 shebang 的时候，会将 %c（小写字母）替换为 %C（大些字母），而 %C 对应的是 shebang 中设定值，即 Rscript。 正常情况下，当前文件 %s 会被逐行输出（&amp;lt;）为 R 命令的标准输入，R 命令支持命令行模式。 但是 Rscript 命令只支持文件名作为输入参数，因此触发了报错。诡异的报错信息就是简单粗暴的 &amp;lsquo;file name is missing&amp;rsquo;（R 相关的设计一直都很随意，大多数的文档和报错信息都云里雾里的。）。 可以测试这个例子：</description></item><item><title>Write Rcpp Package in Vim</title><link>//blog.yech.xyz/posts/write_rcpp_package_in_vim/</link><pubDate>Sun, 22 Mar 2020 00:11:50 +0800</pubDate><guid>//blog.yech.xyz/posts/write_rcpp_package_in_vim/</guid><description>Plenty of tutorials have been posted online for writing Rcpp packages in Rstudio, but few tutorials mention developing R packages in vim.
After some attempt, I have figure out the solution by myself.
install requirement Rcpp in R neovim (with coc.nvim) ccls clang set up a new project R -e &amp;#39;Rcpp::Rcpp.package.skeleton(&amp;#34;mypackage&amp;#34;)&amp;#39; cd ./mypackage setup project create ccls config file (.ccls) in the project, and fill it with the following settings.</description></item><item><title>Cascade Notation in Dart is Magic</title><link>//blog.yech.xyz/posts/dart_tip_1/</link><pubDate>Thu, 12 Mar 2020 18:43:07 +0800</pubDate><guid>//blog.yech.xyz/posts/dart_tip_1/</guid><description>在编写 Python 代码的时候，sort() 和 sorted() 是两个不同的函数，对于列表 l = [2, 6, 1]， 可以用 l.sort() 来进行排序，也可以用 sorted(l) 来进行排序。但是如果打印出来会发现，
&amp;gt;&amp;gt;&amp;gt; print(l.sort()) None &amp;gt;&amp;gt;&amp;gt; print(sorted(l)) [1, 2, 6] 原因是 sorted() 返回（return）的是变换后的列表，.sort() 是对列表进行原位地排序，虽然列表改变了，但是返回的是 None。 所以要输出 .sort() 的结果，需要两步。
&amp;gt;&amp;gt;&amp;gt; l.sort() &amp;gt;&amp;gt;&amp;gt; print(l) [1, 2, 6] 这可能是 Python 维护了两个排序函数的原因，同时 sorted 的使用频率也高一点。
Dart 语言里面 List 也有 .sort() 函数，和 Python 类似，运行以下代码，输出的结果是 {null}。
void main() { var l = [2, 6, 1]; print(l.sort()); } 但是 Dart 里面无需额外的 sorted() 函数来实现这个功能，只要把 l.sort() 换成 l.</description></item><item><title>随手记录点vim技巧(六)</title><link>//blog.yech.xyz/posts/vim_tip_6/</link><pubDate>Sat, 22 Feb 2020 01:16:22 +0800</pubDate><guid>//blog.yech.xyz/posts/vim_tip_6/</guid><description>Q: 怎么查看 vim 中某个单词/高亮的 syntax 的类型？
(想修改某一单词的高亮颜色（highlight）或是语法类型（syntax），但如何快速地判断当前被匹配上的类型？)
设置快捷键：
map &amp;lt;F10&amp;gt; :echo &amp;#34; \ hi&amp;lt;&amp;#34; . synIDattr(synID(line(&amp;#34;.&amp;#34;),col(&amp;#34;.&amp;#34;),1),&amp;#34;name&amp;#34;) . &amp;#34;&amp;gt; \ trans&amp;lt;&amp;#34; . synIDattr(synID(line(&amp;#34;.&amp;#34;),col(&amp;#34;.&amp;#34;),0),&amp;#34;name&amp;#34;) . &amp;#34;&amp;gt; \ lo&amp;lt;&amp;#34; . synIDattr(synIDtrans(synID(line(&amp;#34;.&amp;#34;),col(&amp;#34;.&amp;#34;),1)),&amp;#34;name&amp;#34;) . &amp;#34;&amp;gt; \ &amp;#34;&amp;lt;CR&amp;gt;其中， synID 获取 syntax 的 ID，参数分别为（行号，列号，TRUE/FALSE1）; synIDtrans 获取 highlight 的 ID，参数分别为（行号，列号，TRUE/FALSE1）; synIDattr 获取 ID 对应的 syntax 名称（&amp;ldquo;name&amp;rdquo;）。
光标定位至感兴趣的单词，按 F10 显示 syntax 和 highlight 的名称，例如：
hi&amp;lt;vimMap&amp;gt; trans&amp;lt;vimMap&amp;gt; lo&amp;lt;vimCommand&amp;gt;
查看 syntax 的正则表达式：
:syntax list在结果定位 syntax 名称的关键词。</description></item><item><title>Fcitx5 as Chinese Input Method</title><link>//blog.yech.xyz/posts/fcitx5_as_chinese_input_method/</link><pubDate>Thu, 06 Feb 2020 17:13:56 +0800</pubDate><guid>//blog.yech.xyz/posts/fcitx5_as_chinese_input_method/</guid><description>安装 Archlinux 最后一件事往往是安装搜狗输入法，这也是最困难的一件事。
从 AUR 编译源码需要花费大量的时间（低配置的 Laptop 上需要半天）。 为了兼容 QT4, QT5, GTK4, GTK5, XIM 等框架的应用，需要各种调试。 搜狗输入法带有 bug，经常无法调出输入法，或是输入皮肤不显示。 这直到 fcitx5 发布，一切终于有了转机会。 若非进行大量的中文写作，fcitx5 中的拼音插件1完全可以胜任日常的中文输入。
fcitx5 安装及配置步骤也非常简单，而且稳定性出奇的好。大致步骤如下：
安装 fcitx5：
从 AUR 安装2：
yay -S fcitx5-git fcitx5-qt5-git fcitx5-gtk-git fcitx5-chinese-addons-git 若配置了 ArchlinuxCN3，从 ArchlinuxCN 安装：
pacman -S fcitx5-git fcitx5-qt5-git fcitx5-gtk-git fcitx5-chinese-addons-git 设置 fcitx5 的开启：
基于 Xorg 的桌面环境，添加配置到 ~/.xprofile：
export GTK_IM_MODULE=fcitx5 export XMODIFIERS=&amp;quot;@im=fcitx&amp;quot; export QT_IM_MODULE=fcitx5 fcitx5 &amp;gt; /dev/null &amp;amp; 基于 Wayland 的桌面环境，添加配置到 ~/.</description></item><item><title>随手记录点vim技巧(五)</title><link>//blog.yech.xyz/posts/vim_tip_5/</link><pubDate>Thu, 30 Jan 2020 14:50:30 +0800</pubDate><guid>//blog.yech.xyz/posts/vim_tip_5/</guid><description> Q: 怎么查看 vim 启动时加载的脚本？
(启动 vim 时怎么 debug？)
查看 vim 加载时执行了哪些脚本（加载了那些插件）:
:scriptnames&amp;#39; or `:scr` for short查看每一个脚本/插件的耗时：
vim --startuptime start_time.log filename 不加载插件启动：
# vim vim --clean # neovim nvim --noplugin 指定从另外的配置文件启动：
vim -u min.vim filename Reference
http://www.wepeng.net/article/detail/100518128.html</description></item><item><title>Fix Chrome Emoji Rendering Issue</title><link>//blog.yech.xyz/posts/fix_chrome_emoji_rendering_issue/</link><pubDate>Thu, 07 Mar 2019 02:44:14 +0800</pubDate><guid>//blog.yech.xyz/posts/fix_chrome_emoji_rendering_issue/</guid><description>&lt;p>Chrome/Chromium 下部分 emoji 符号显示出来怎么是小方块？而同样的字符在 Firefox 能正常显示。&lt;/p></description></item><item><title>Shell Shortcut</title><link>//blog.yech.xyz/posts/shell_shortcut/</link><pubDate>Tue, 05 Mar 2019 19:21:46 +0800</pubDate><guid>//blog.yech.xyz/posts/shell_shortcut/</guid><description>Some useful bash shortcut for me.
key method Ctrl + a Move to the beginning of the line Ctrl + e Move to the end of the line Ctrl + u (bash) Clear the characters on the line before the current cursor position Ctrl + u (zsh) If you&amp;rsquo;re using the zsh, this will clear the entire line Ctrl + k Clear the characters on the line after the current cursor position Ctrl + w Delete the word in front of the cursor Ctrl + r Search history Ctrl + g Escape from search mode Ctrl + - Undo the last change Ctrl + s Stop output to screen Ctrl + q Re-enable screen output Ctrl + c Terminate/kill current foreground process Ctrl + z Suspend/stop current foreground process Alt + d Delete the word after the cursor Ctrl + l Clear screen Ctrl + j Sent Enter Ctrl + j Delete one charater before cursor</description></item><item><title>Workflow Setup and Run</title><link>//blog.yech.xyz/posts/workflow_setup_and_run/</link><pubDate>Fri, 01 Mar 2019 23:54:43 +0800</pubDate><guid>//blog.yech.xyz/posts/workflow_setup_and_run/</guid><description>Workflow
Framework (Tools) Snakemake WDL nextflow CWL Martian (Pipeline Manager developed by 10x Genomics for Cellranger) make (GNU) Comparision There are two types of workflow system.
backward (pull) (output -&amp;gt; input) eg, make, snakemake
forward (push) (input -&amp;gt; output) eg, nextflow, SciPipe</description></item><item><title>随手记录点vim技巧(四)</title><link>//blog.yech.xyz/posts/vim_tip_4/</link><pubDate>Thu, 28 Feb 2019 01:54:11 +0800</pubDate><guid>//blog.yech.xyz/posts/vim_tip_4/</guid><description>&lt;blockquote>
&lt;p>Q: 怎么快速删除每一行最后一个字符?
（怎么录制宏？）&lt;/p>
&lt;/blockquote>
&lt;p>例如一个文件每一行最后一个字符是句号，需要把它们都去掉。&lt;/p></description></item><item><title>Proxy Gitea as Caddy Subpath</title><link>//blog.yech.xyz/posts/proxy_gitea_as_caddy_subpath/</link><pubDate>Tue, 26 Feb 2019 03:04:42 +0800</pubDate><guid>//blog.yech.xyz/posts/proxy_gitea_as_caddy_subpath/</guid><description>&lt;p>Using Caddy with a Sub-path as a reverse proxy.&lt;/p>
&lt;p>Gitea and Caddy are on different server.&lt;/p></description></item><item><title>Linux 系统中的字体配置</title><link>//blog.yech.xyz/posts/edit_fontconfig_in_linux/</link><pubDate>Tue, 19 Feb 2019 16:59:41 +0800</pubDate><guid>//blog.yech.xyz/posts/edit_fontconfig_in_linux/</guid><description>Linux 系统中多采用 Fontconfig 对字体进行管理和配置。 其配置文件1为 XML 的格式，可以通过对字体进行映射来实现“重命名”的效果。
为什么安装了 Noto 的中文字体，但是依然没法在网页中正常调用？
ArchLinux 中的 noto-fonts-cjk 字体包会安装Noto Serif CJK TC、Noto Serif CJK KR、Noto Serif CJK SC 等字体文件，但是网页中的 Noto 中文字体调用多为Noto Serif SC这样的命名，导致安装字体后不起作用。因此可以对Noto Serif SC字体的调用进行映射：
&amp;lt;?xml version=&amp;#34;1.0&amp;#34;?&amp;gt; &amp;lt;!DOCTYPE fontconfig SYSTEM &amp;#34;fonts.dtd&amp;#34;&amp;gt; &amp;lt;fontconfig&amp;gt; &amp;lt;match target=&amp;#34;pattern&amp;#34;&amp;gt; &amp;lt;test qual=&amp;#34;any&amp;#34; name=&amp;#34;family&amp;#34;&amp;gt; &amp;lt;string&amp;gt;Noto Serif SC&amp;lt;/string&amp;gt; &amp;lt;/test&amp;gt; &amp;lt;edit name=&amp;#34;family&amp;#34; mode=&amp;#34;assign&amp;#34; binding=&amp;#34;same&amp;#34;&amp;gt; &amp;lt;string&amp;gt;Noto Serif CJK SC&amp;lt;/string&amp;gt; &amp;lt;/edit&amp;gt; &amp;lt;/match&amp;gt; &amp;lt;match target=&amp;#34;pattern&amp;#34;&amp;gt; &amp;lt;test qual=&amp;#34;any&amp;#34; name=&amp;#34;family&amp;#34;&amp;gt; &amp;lt;string&amp;gt;Noto Serif TC&amp;lt;/string&amp;gt; &amp;lt;/test&amp;gt; &amp;lt;edit name=&amp;#34;family&amp;#34; mode=&amp;#34;assign&amp;#34; binding=&amp;#34;same&amp;#34;&amp;gt; &amp;lt;string&amp;gt;Noto Serif CJK TC&amp;lt;/string&amp;gt; &amp;lt;/edit&amp;gt; &amp;lt;/match&amp;gt; &amp;lt;/fontconfig&amp;gt; fc-cache -fv 重新生成字体配置的缓存。 fc-list 查看系统中的字体文件信息，但配置中的字体印射不在结果中显示。 fc-match &amp;quot;Noto Serif SC&amp;quot; 测试系统字体的调用。 Fontconfig 2.</description></item><item><title>Customize Deepin Desktop for Archlinux</title><link>//blog.yech.xyz/posts/customize_deepin_desktop_for_archlinux/</link><pubDate>Tue, 05 Feb 2019 18:28:41 +0800</pubDate><guid>//blog.yech.xyz/posts/customize_deepin_desktop_for_archlinux/</guid><description> 在英文环境中打开日历的农历显示？[1]
创建配置文件：~/.config/deepin/dde-calendar.conf
在其中添加 EnableLunar=true
修改窗口的标题栏宽度？[2]
创建配置文件：
~/.local/share/deepin/themes/deepin/light/titlebar.ini(If you use light theme)
或 ~/.local/share/deepin/themes/deepin/dark/titlebar.ini (If you use dark theme)
在其中添加
``` [Active] height=25 [Inactive] height=25 ``` 注：仅对 deepin-kwin 生效，对 deepin-wm 无效。
Reference
https://bbs.deepin.org/forum.php?mod=viewthread&amp;amp;tid=154593&amp;amp;extra=&amp;amp;page=2 https://github.com/linuxdeepin/developer-center/issues/1210</description></item><item><title>Use Black as Formatter for Jupyter Notebook</title><link>//blog.yech.xyz/posts/use_black_as_formatter_for_jupyter_notebook/</link><pubDate>Thu, 31 Jan 2019 20:34:01 +0800</pubDate><guid>//blog.yech.xyz/posts/use_black_as_formatter_for_jupyter_notebook/</guid><description>How to setup?
Install Nbextensions in jupyter notebook.
see https://github.com/ipython-contrib/jupyter_contrib_nbextensions#1-install-the-python-package
Enable code prettify Nbextensions in jupyter notebook.
check the box in setting page
Paste the configuration below into Prameters.
{ &amp;#34;python&amp;#34;: { &amp;#34;library&amp;#34;: &amp;#34;import json\ndef black_reformat(cell_text):\n import black\n import re\n cell_text = re.sub(&amp;#39;^%&amp;#39;, &amp;#39;#%#&amp;#39;, cell_text, flags=re.M)\n try:\n reformated_text = black.format_str(cell_text, 88)\n except TypeError:\n reformated_text = black.format_str(cell_text, mode=black.FileMode(line_length=88))\n return re.sub(&amp;#39;^#%#&amp;#39;, &amp;#39;%&amp;#39;, reformated_text, flags=re.M)&amp;#34;, &amp;#34;prefix&amp;#34;: &amp;#34;print(json.</description></item><item><title>Set Default PDF Reader in Linux</title><link>//blog.yech.xyz/posts/set_default_pdf_reader_in_linux/</link><pubDate>Thu, 29 Mar 2018 21:41:30 +0800</pubDate><guid>//blog.yech.xyz/posts/set_default_pdf_reader_in_linux/</guid><description> solve the problem that gimp open pdf as default
check filetype of a certain file
xdg-mime query filetype xxx.pdf check default mimetype of a certain filetype
xdg-mime query default application/pdf set default mimetype for a certain filetype
xdg-mime default evince.desktop application/pdf Reference:
https://superuser.com/questions/170035/pdfs-open-in-gimp-on-linux-system</description></item><item><title>Python and Cython Typing</title><link>//blog.yech.xyz/posts/python_and_cython_typing/</link><pubDate>Mon, 05 Mar 2018 19:12:53 +0800</pubDate><guid>//blog.yech.xyz/posts/python_and_cython_typing/</guid><description>PEP 526 Cython 0.27 Python 是一门充满活力的语言，除了相关的包在快速的增加以外，Python 自身的语法特性也在不断推进。 然而这种变化被 Python2 和 Python3 的差异所掩盖，人们往往只关注 Python3 中引入与 Python2 不兼容的部分，而忽视了 Python3 本身也在不断改进。 Python 3.5/3.6 推出不少新的语法特性。虽然都不是强制性的，但如果不主动遵循，几年后别人看你的代码，就好像现在写 Python3 的人看 Pyhton2 代码一般。
类型声明 Python 是动态语言，不需要像静态语言（C、java）那样声明变量类型。但这在写较大型的项目的时候反而会成为劣势，所以这几年 Python 试图引入统一的变量声明语法，这种改变好比 JavaScript 到 TypeScript 的变化。 PEP 484 在注释中加入了 typing，而 Python 3.6 的 PEP 526 更为彻底，可以在代码中用类似 var: type 的格式添加类型注释。
PEP 526 用到的注释方式和 Golang 类似，变量名在前，变量类型在后。 似乎新生的语言 Rust，TypeScript 偏好这种模式，而传统的语言 C，Java 采用相反的模式。
之前的写法：
def fun(n): &amp;#34;&amp;#34;&amp;#34;Print the Fibonacci series up to n.&amp;#34;&amp;#34;&amp;#34; a = 0 b = 1 while b &amp;lt; n: a, b = b, a + b return b 新的写法：</description></item><item><title>How to Publish a Hugo Project to Remote Server Automatically?</title><link>//blog.yech.xyz/posts/hugo_by_webhook/</link><pubDate>Sat, 03 Mar 2018 16:21:39 +0800</pubDate><guid>//blog.yech.xyz/posts/hugo_by_webhook/</guid><description>&lt;p>A pipeline for blogging automatically though Github&lt;/p>
&lt;h2 id="purpose">Purpose&lt;/h2>
&lt;p>write and serve markdown blog without caring about the html, theme, archiving, server, website, domain &amp;hellip;&lt;/p></description></item><item><title>随手记录点vim技巧(三)</title><link>//blog.yech.xyz/posts/vim_tip_3/</link><pubDate>Thu, 01 Feb 2018 15:21:53 +0800</pubDate><guid>//blog.yech.xyz/posts/vim_tip_3/</guid><description>&lt;blockquote>
&lt;p>Q: vim 怎么快速插入 iso-8601 格式的时间戳？&lt;/p>
&lt;/blockquote></description></item><item><title>在R语言中使用并行</title><link>//blog.yech.xyz/posts/paralle_in_r/</link><pubDate>Wed, 31 Jan 2018 00:11:14 +0800</pubDate><guid>//blog.yech.xyz/posts/paralle_in_r/</guid><description>&lt;p>R 语言天生具有数据框处理的优势，这种优势掩盖了 R 中循环体的劣势，这间接导致了 R 并行难度大，各种包良莠不齐。&lt;/p></description></item><item><title>How to use bioawk</title><link>//blog.yech.xyz/posts/how_to_use_bioawk/</link><pubDate>Mon, 29 Jan 2018 10:58:08 +0800</pubDate><guid>//blog.yech.xyz/posts/how_to_use_bioawk/</guid><description>在 Linux 命令行处理文件过程中,合并文件是一个最基本的操作。
例如有 file1，file2，file3 几个文件，想合并成一个大文件 fileall，这个几乎有个标准答案：
cat file1 file2 file3 &amp;gt; fileall 简单再说两点,
cat是 concatenate 的缩写，本身就是串联的意思。用cat来 print out 文件反而不是这个单词本身的含义。
如果是 bash 下，且文件名称是连续的，cat file{1..3} &amp;gt; fileall应该是逼格更高的写法。
而实际需求很少是上面这么直接，更常见的需求是要文件名也放到最终文件中，以区别不同的样品类型，数据来源之类的。这时候就需要拿出awk，代码实现也非常直接：
# 将文件名作为输出数据的第一列 awk &amp;#39;{FILENAME,$0}&amp;#39; file{1..3} &amp;gt; fileall awk 基本可以实现大部分的文件操作。 网上会把 sed 和 awk 放在一起封神，而 sed 之于 awk，有如 emacs 至于 vim。 一个是神的工具，一个是工具之神。 linux 下有不是这样有趣的组合，前者功能强大，但学习成本略高，后者功能少了一点，但思路清晰，上手快。
在引出文章的主角bioawk之前，还要把需求再弄复杂一点。
如果文件是都 gzip 压缩的话，是否也能解决呢？
这个其实不少见，比如多个.bed.gz 文件合并，多个.fq.gz 文件合并&amp;hellip;
把文件都解压后再操作是一个方法，不过这时候除了浪费空间外，还多了两次IO。
linux 下zcat命令可以进行 gzip 格式文件的读取，因而有类似的操作：</description></item><item><title>google的dnsmasq地址和IP</title><link>//blog.yech.xyz/posts/google_dnsmasq/</link><pubDate>Wed, 24 Feb 2016 05:13:25 +0800</pubDate><guid>//blog.yech.xyz/posts/google_dnsmasq/</guid><description>&lt;p>google dnsmasq address&lt;/p></description></item><item><title>Markup Language</title><link>//blog.yech.xyz/posts/markup_language/</link><pubDate>Sat, 02 Jan 2016 14:33:50 +0800</pubDate><guid>//blog.yech.xyz/posts/markup_language/</guid><description> markdown AsciiDoc Org-mode Textile txt2tags Wiki markup</description></item><item><title>vimium like setting for surfingkeys</title><link>//blog.yech.xyz/posts/surfingkeys_vimium_like_setting/</link><pubDate>Fri, 01 Jan 2016 01:14:32 +0800</pubDate><guid>//blog.yech.xyz/posts/surfingkeys_vimium_like_setting/</guid><description>&lt;p>A conf file of surfingkeys for vimium user&lt;/p></description></item><item><title>随手记录点vim技巧(二)</title><link>//blog.yech.xyz/posts/vim_tip_2/</link><pubDate>Sun, 27 Dec 2015 23:41:23 +0800</pubDate><guid>//blog.yech.xyz/posts/vim_tip_2/</guid><description>&lt;blockquote>
&lt;p>Q: 删除到/插入到/移动到 行首怎么搞?&lt;/p>
&lt;/blockquote></description></item><item><title>随手记录点vim技巧(一)</title><link>//blog.yech.xyz/posts/vim_tip_1/</link><pubDate>Sun, 27 Dec 2015 13:41:23 +0800</pubDate><guid>//blog.yech.xyz/posts/vim_tip_1/</guid><description>&lt;blockquote>
&lt;p>Q: 粘贴段落的时候, 自动缩进和加注释符, 格式都乱了, 怎么办?&lt;/p>
&lt;/blockquote></description></item><item><title>随手记录点vim技巧</title><link>//blog.yech.xyz/posts/vim_tip/</link><pubDate>Sun, 27 Dec 2015 13:41:16 +0800</pubDate><guid>//blog.yech.xyz/posts/vim_tip/</guid><description>这个系列叫“随手记录点 vim 技巧”
大概就是把自己重复遇到过几次以上的 vim 问题记录起来，现在记性不好了</description></item><item><title>在浏览器中登陆terminal</title><link>//blog.yech.xyz/posts/chrome_webshell/</link><pubDate>Sat, 26 Dec 2015 17:50:49 +0800</pubDate><guid>//blog.yech.xyz/posts/chrome_webshell/</guid><description>&lt;p>chrome 的应用 &lt;code>secure shell&lt;/code> 能非常方便的实现 SSH 客户端的功能，并且能像修改网页属性那样修改应用的外观。&lt;/p>
&lt;p>安装和配置都非常简单。&lt;/p></description></item><item><title>常用的前端框架</title><link>//blog.yech.xyz/posts/fontend_js_framework/</link><pubDate>Fri, 25 Dec 2015 10:54:10 +0800</pubDate><guid>//blog.yech.xyz/posts/fontend_js_framework/</guid><description>前端框架 MVVM, MVC 什么的还不清楚&amp;hellip;
angular vue react ant-design jQuery extjs zepto jQuery jQueryUI : javascript 框架和前端框架不是一个东西?
##转
infoQ
Backbone.js: Provides models with key-value binding and custom events, collections, and connects it all to your existing API over a RESTful JSON interface. AngularJS: A toolset based on extending the HTML vocabulary for your application. Ember.js: Provides template written in the Handlebars templating language, views, controllers, models and a router.</description></item><item><title>比较同步编程和异步编程的区别</title><link>//blog.yech.xyz/posts/compair_sync_and_async/</link><pubDate>Wed, 23 Dec 2015 15:21:01 +0800</pubDate><guid>//blog.yech.xyz/posts/compair_sync_and_async/</guid><description>Sync in C
#include &amp;lt;time.h&amp;gt;#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;unistd.h&amp;gt;int main() { int i; time_t the_time; for(i = 1; i &amp;lt;= 10; i++) { the_time = time((time_t *)0); printf(&amp;#34;The time is %ld\n&amp;#34;, the_time); sleep(2); } exit(0); } The time is 1396492137 The time is 1396492139 The time is 1396492141 The time is 1396492143 The time is 1396492145 The time is 1396492147 The time is 1396492149 The time is 1396492151 The time is 1396492153 The time is 1396492155 Async in javascript function test() { for (var i = 0; i &amp;lt; 10; i++) { console.</description></item><item><title>node.js 学习笔记(四)</title><link>//blog.yech.xyz/posts/learn_nodejs_note_4/</link><pubDate>Wed, 23 Dec 2015 14:42:59 +0800</pubDate><guid>//blog.yech.xyz/posts/learn_nodejs_note_4/</guid><description>用 node 的 express 插件创建应用 创建项目环境 mkdir myapp cd myapp npm install express --save vim app.js 编写 javascript 脚本 //app.js 内容 var express = require(&amp;#34;express&amp;#34;); var app = express(); app.get(&amp;#34;/&amp;#34;, function (req, res) { res.send(&amp;#34;Hello World!&amp;#34;); }); var server = app.listen(3000, function () { var host = server.address().address; var port = server.address().port; console.log(&amp;#34;Example app listening at http://%s:%s&amp;#34;, host, port); }); 启动服务,监听 3000 端口 node app.</description></item><item><title>node.js 学习笔记(三)</title><link>//blog.yech.xyz/posts/learn_nodejs_note_3/</link><pubDate>Tue, 22 Dec 2015 00:09:42 +0800</pubDate><guid>//blog.yech.xyz/posts/learn_nodejs_note_3/</guid><description>网页端的 javascript 和服务端的 nodejs 的区别 网页端</description></item><item><title>node.js 学习笔记(二)</title><link>//blog.yech.xyz/posts/learn_nodejs_note_2/</link><pubDate>Mon, 21 Dec 2015 14:01:05 +0800</pubDate><guid>//blog.yech.xyz/posts/learn_nodejs_note_2/</guid><description>运行环境 两种,类似 python
命令行交互 $ node &amp;gt; console.log(&amp;#34;Hello World&amp;#34;); 文件运行(无需编译) $ echo &amp;#39;console.log(&amp;#34;Hello World&amp;#34;)&amp;#39; &amp;gt; helloworld.js $ node helloworld.js</description></item><item><title>node.js 学习笔记(一)</title><link>//blog.yech.xyz/posts/learn_nodejs_note_1/</link><pubDate>Sun, 20 Dec 2015 16:21:23 +0800</pubDate><guid>//blog.yech.xyz/posts/learn_nodejs_note_1/</guid><description>ubuntu 安装 nodejs5 将 nodejs 添加到源 wget -qO- https://deb.nodesource.com/setup_5.x | sudo bash - 安装 nodejs sudo apt-get install --yes nodejs</description></item><item><title>javascript 学习笔记</title><link>//blog.yech.xyz/posts/learn_javascript_note/</link><pubDate>Sun, 20 Dec 2015 14:01:05 +0800</pubDate><guid>//blog.yech.xyz/posts/learn_javascript_note/</guid><description>记录一下 js 的笔记
&amp;hellip;</description></item><item><title>node.js 学习笔记</title><link>//blog.yech.xyz/posts/learn_nodejs_note/</link><pubDate>Sun, 20 Dec 2015 14:01:05 +0800</pubDate><guid>//blog.yech.xyz/posts/learn_nodejs_note/</guid><description>记录一下 nodejs 的小知识
update in 2019-02-28:
这个系列应该是凉了</description></item></channel></rss>