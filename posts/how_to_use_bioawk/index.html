<!doctype html><html><head><title>How to use bioawk</title><meta charset=utf-8><meta name=X-UA-Compatible content="IE=edge"><meta name=google-site-verification content><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0" name=viewport><meta content="telephone=no" name=format-detection><meta name=description content><meta name=renderer content="webkit"><meta name=theme-color content="#ffffff"><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');ga('create','UA-71962122-1','auto');ga('send','pageview');}</script><script src=/vendor/js/jquery.min.js></script><script src=/vendor/js/popper.min.js></script><script src=/vendor/js/bootstrap.min.js></script><script src=/vendor/js/smooth-scroll.polyfills.min.js></script><link type=text/css rel=stylesheet href=/vendor/css/bootstrap.min.css><script src=/vendor/js/vue.min.js></script><link rel=icon href=favicon-96x96.png><link rel=stylesheet href=//blog.yech.xyz/scss/journal.min.5c667e74038e21ddbb9024b67930f8544e02af62491281cf73fdb817eec2947e.css integrity="sha256-XGZ+dAOOId27kCS2eTD4VE4Cr2JJEoHPc/24F+7ClH4=" media=screen><script src=//blog.yech.xyz//js/loadCSS.js></script><script src=//blog.yech.xyz//js/table.js></script><script src=//blog.yech.xyz//js/toc.js></script><script>loadCSS("https://fonts.googleapis.com/css?family=Lora|Montserrat|Fira+Mono|Noto+Serif+SC|Material+Icons");</script></head><body><div id=app><div ref=sideContainer class=side-container><a class="a-block nav-head false" href=//blog.yech.xyz/><div class=nav-title>Chang's blog</div><div class=nav-subtitle>learn and share...</div></a><div class=nav-link-list><a class="a-block nav-link-item false" href=/categories>Categories</a>
<a class="a-block nav-link-item false" href=/tags>Tags</a></div><div class=nav-footer>Hugo Theme <a href=https://github.com/amazingrise/hugo-theme-diary>Diary</a> by <a href=https://amazingrise.net>Rise</a><br>Ported from <a href=https://mak1t0.cc/ target=_blank rel="noreferrer noopener">Makito</a>'s <a href=https://github.com/SumiMakito/hexo-theme-journal/ target=_blank rel="noreferrer noopener">Journal.</a><br><br>&copy;
2020 by Ye Chang</div></div><div ref=extraContainer class=extra-container><div class="toc animated-visibility" :class="{ invisible: scrollY <= 140 }"></div><div class=pagination><a id=globalBackToTop class="pagination-action animated-visibility" href=#top :class="{ invisible: scrollY == 0 }"><i class="material-icons pagination-action-icon">keyboard_arrow_up</i></a></div></div><div class=single-column-drawer-container ref=drawer v-bind:class="{ 'single-column-drawer-container-active': isDrawerOpen }"><div class=drawer-content><div class=drawer-menu><a class="a-block drawer-menu-item false" href=/categories>Categories</a>
<a class="a-block drawer-menu-item false" href=/tags>Tags</a><div class=toc></div></div></div></div><transition name=fade><div v-bind:class="{ 'single-column-drawer-mask': mounted }" v-if=isDrawerOpen v-on:click=toggleDrawer></div></transition><nav ref=navBar class="navbar sticky-top navbar-light single-column-nav-container"><div ref=navBackground class=nav-background></div><div class="container container-narrow nav-content"><button id=nav_dropdown_btn class=nav-dropdown-toggle type=button v-on:click=toggleDrawer>
<i class=material-icons>menu</i></button>
<a ref=navTitle class=navbar-brand href=//blog.yech.xyz/>Chang's blog</a></div></nav><div class=single-column-header-container ref=pageHead v-bind:style="{ transform: 'translateZ(0px) translateY('+.3*scrollY+'px)', opacity: 1-navOpacity }"><a href=//blog.yech.xyz/><div class=single-column-header-title>Chang's blog</div><div class=single-column-header-subtitle>learn and share...</div></a></div><div id=content><div ref=streamContainer class=stream-container><div class="post-list-container post-list-container-shadow"><div class=post><div class=post-head-wrapper style=background-image:url(/img/bioawk.png)><div class=post-title>How to use bioawk<div class=post-meta><time itemprop=datePublished>2018-01-29 10:58</time>
<i class=material-icons>folder</i>
<a href=/categories/coding>coding</a>
&nbsp;
<i class=material-icons>label</i>
<a href=/tags/bio>bio</a>
&nbsp;
<a href=/tags/linux>linux</a>
&nbsp;</div></div></div><div class=post-body-wrapper><div class=post-body><p>在 Linux 命令行处理文件过程中,合并文件是一个最基本的操作。</p><p>例如有 file1，file2，file3 几个文件，想合并成一个大文件 fileall，这个几乎有个标准答案：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>cat file1 file2 file3 &gt; fileall
</code></pre></div><p>简单再说两点,</p><ul><li><p><code>cat</code>是 concatenate 的缩写，本身就是串联的意思。用<code>cat</code>来 print out 文件反而不是这个单词本身的含义。</p></li><li><p>如果是 bash 下，且文件名称是连续的，<code>cat file{1..3} > fileall</code>应该是逼格更高的写法。</p></li></ul><p>而实际需求很少是上面这么直接，更常见的需求是要文件名也放到最终文件中，以区别不同的样品类型，数据来源之类的。这时候就需要拿出<code>awk</code>，代码实现也非常直接：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#75715e># 将文件名作为输出数据的第一列</span>
awk <span style=color:#e6db74>&#39;{FILENAME,$0}&#39;</span> file<span style=color:#f92672>{</span>1..3<span style=color:#f92672>}</span> &gt; fileall
</code></pre></div><p>awk 基本可以实现大部分的文件操作。
网上会把 sed 和 awk 放在一起封神，而 sed 之于 awk，有如 emacs 至于 vim。
一个是神的工具，一个是工具之神。
linux 下有不是这样有趣的组合，前者功能强大，但学习成本略高，后者功能少了一点，但思路清晰，上手快。</p><p>在引出文章的主角<code>bioawk</code>之前，还要把需求再弄复杂一点。</p><p>如果文件是都 gzip 压缩的话，是否也能解决呢？</p><blockquote><p>这个其实不少见，比如多个.bed.gz 文件合并，多个.fq.gz 文件合并&mldr;</p></blockquote><p>把文件都解压后再操作是一个方法，不过这时候除了浪费空间外，还多了<strong>两次</strong>IO。</p><p>linux 下<code>zcat</code>命令可以进行 gzip 格式文件的读取，因而有类似的操作：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>zcat file<span style=color:#f92672>{</span>1..3<span style=color:#f92672>}</span>.gz &gt; fileall
</code></pre></div><p>但是<code>awk</code>不能读取 gzip 文件。能否用<code>zcat</code>加上<code>awk</code>来实现带上文件名的合并呢？
先试一下这个：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#75715e># test1</span>
zcat file<span style=color:#f92672>{</span>1..3<span style=color:#f92672>}</span>.gz | awk <span style=color:#e6db74>&#39;{FILENAME,$0}&#39;</span> &gt; fileall
</code></pre></div><p>咦，文件名都去哪了？怎么都是&rsquo;-'？</p><p>原因是 pipe 操作传输的是 stdout 给下一步，而 stdout 就是&rsquo;-'。如果要把文件名也传过来怎么办呢？直接扔代码:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#75715e># test2</span>
<span style=color:#66d9ef>for</span> i in file<span style=color:#f92672>{</span>1..3<span style=color:#f92672>}</span>.gz; <span style=color:#66d9ef>do</span> awk <span style=color:#e6db74>&#39;{&#34;&#39;</span><span style=color:#e6db74>&#34;</span>$i<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>&#39;&#34;,$0}&#39;</span> $i&gt; fileall; <span style=color:#66d9ef>done</span>
</code></pre></div><p>两个 defect: 不优雅的 for 循环；4 层嵌套的引号狂魔。</p><p>这时候可以召唤主角了，liheng 大神的<a href=https://github.com/lh3/bioawk>bioawk</a>，基于 C 语言，速度快，功能全，不是那些妖艳的脚本语言实现。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#75715e># test1</span>
bioawk <span style=color:#e6db74>&#39;{FILENAME,$0}&#39;</span> file<span style=color:#f92672>{</span>1..3<span style=color:#f92672>}</span>.gz &gt; fileall
</code></pre></div><p>这不是可以支持 gzip 格式的 awk 么？有什么了不起的？</p><p>下面开始讲<code>bioawk</code>的了不起之处。</p><p>bioawk 是针对生物数据分析开发的软件，除了具有 awk 的功能外，还有针对特定格式的应用。
加<code>-c</code>参数加文件类型，可以让 bioawk 针对文件类型进行操作。
支持的文件格式有 bed，sam，vcf，gff，fastx(fastq/fasta)。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>bioawk -c help

---

bed:
	1:chrom 2:start 3:end 4:name 5:score 6:strand 7:thickstart 8:thickend 9:rgb 10:blockcount 11:blocksizes 12:blockstarts
sam:
	1:qname 2:flag 3:rname 4:pos 5:mapq 6:cigar 7:rnext 8:pnext 9:tlen 10:seq 11:qual
vcf:
	1:chrom 2:pos 3:id 4:ref 5:alt 6:qual 7:filter 8:info
gff:
	1:seqname 2:source 3:feature 4:start 5:end 6:score 7:strand 8:frame 9:attribute
fastx:
	1:name 2:seq 3:qual 4:comment

</code></pre></div><p>如果要统计一个 fastq 文件的长度大于 200bp 的序列条数，用 awk 的实现如下：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>awk <span style=color:#e6db74>&#39;NR%4==2{if(length($1)&gt;200){a+=1}}END{print a}&#39;</span> file.fq
</code></pre></div><p>bioawk 实现如下：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>bioawk -c fastx <span style=color:#e6db74>&#39;{if(length($seq)&gt;200){a+=1}}END{print a}&#39;</span> file.fq
</code></pre></div><p>可以看到，差别在于不用判定行数，bioawk 能自动提取序列。</p><p>如果文件是 fasta 格式，这种优势变得更加明显，因为 fasta 文件支持序列跨行，如果同时用 awk 还需要对“>”符号进行判断，合并序列成单行，才能进行后续的统计。
而 bioawk 没有这个问题，liheng 的<code>kseq.h</code>自带跨行读取支持。</p><p>再举一个例子，awk 可以将 sam 文件转成 fastq 文件，实现如下：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>awk <span style=color:#e6db74>&#39;{print &#34;@&#34;$1&#34;\n&#34;$10&#34;\n+\n&#34;$11}&#39;</span> file.sam &gt; file.fq
</code></pre></div><p>用 awk 处理过 sam、vcf、gff 文件的，应该都要这样的体验。
每次要把文件头几行打出来，让后用手指着屏幕，一边数数，一边祈祷能一次过。
然而，实际情况都是要数几次才能数对，因为有些列支持置空，这样的空行会导致后面的列数数少了。
更严重的情况是，有些行是没有太大辨识度的数字，这样还不得不打开文档查文件的说明。</p><p>而<code>bioawk</code>的支持用文件名取列，这样上面的例子可以写成：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>awk <span style=color:#e6db74>&#39;{print &#34;@&#34;$qname&#34;\n&#34;$seq&#34;\n+\n&#34;$qual}&#39;</span> file.sam &gt; file.fq
</code></pre></div><p><em>当然也可以通过<code>bioawk -c help</code>查看说明文件，后用数值编号制定输出列。</em></p><p>还有另一个小技巧，处理文件的时候经常要指定输入文件是 tab 分割，输出文件也用 tab 分割。<code>awk</code> 中用 <code>-F'\t' -v OFS="\t"</code> 参数来指定，而 bioawk 可以直接有 <code>-t</code> 满足一样的需求。</p><blockquote><p>你在编程上遇到的问题，99%都已经解决了。剩下 1%中的 99%是你搞错问题了。</p></blockquote><hr width=100% id=EOF><p style=color:#777>Last modified on 2020-03-26</p></div></div><nav class=post-pagination><a class=newer-posts href=//blog.yech.xyz/posts/happy_new_year_of_dog/>Next<br>狗年好运</a>
<a class=older-posts href=//blog.yech.xyz/posts/top100_journal_for_pubmed/>Previous<br>top100 Journal for pubmed advance search</a></nav><div class=post-comment-wrapper></div></div></div></div></div><div id=single-column-footer>Hugo Theme <a href=https://github.com/amazingrise/hugo-theme-diary>Diary</a> by <a href=https://amazingrise.net>Rise</a><br>Ported from <a href=https://mak1t0.cc/ target=_blank rel="noreferrer noopener">Makito</a>'s <a href=https://github.com/SumiMakito/hexo-theme-journal/ target=_blank rel="noreferrer noopener">Journal.</a><br><br>&copy;
2020 by Ye Chang</div></div><script src=//blog.yech.xyz//js/journal.js></script></body></html>